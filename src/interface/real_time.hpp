/* -*- indent-tabs-mode: t -*- */

#ifndef INQ__INTERFACE__REAL_TIME
#define INQ__INTERFACE__REAL_TIME

// Copyright (C) 2019-2024 Lawrence Livermore National Security, LLC., Xavier Andrade, Alfredo A. Correa
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

#include <input/environment.hpp>
#include <interface/runtime_options.hpp>
#include <systems/electrons.hpp>

namespace inq {
namespace interface {

struct {
		
	constexpr auto name() const {
		return "real-time";
	}

	constexpr auto one_line() const {
		return "Defines the parameters for a real-time calculation";
	}
	
	constexpr auto help() const {
		return R""""(
The 'real-time' command
==================

This command defines the options for real-time electron dynamics
simulations. These are the available options:

- Shell:  `real-time`
  Python: `real_time.status()`

  When no arguments are given (or "status" in python), `real-time` will
  just print the currently defined options (including default values).

  Shell example:  `inq real-time`
  Python example: `pinq.real_time.status()`


- Shell:  `real-time time-step <value> <units>`
  Python: `real_time.time_step(value, units)`

  Sets the time step for the real-time integration. In most cases you
  want to pick the largest value that gives you a stable
  propagation. Note you need to pass the units, you can use "atu" (or
  "atomictimeunits"), "as" or "fs" among others. The default value is
  0.01 atu.

  Shell example:  `inq real-time time-step 0.1 atu`
  Python example: `pinq.real_time.time_step(0.1, "atu")`


- Shell:  `real-time num-steps <value>`
  Python: `real_time.num_steps(value)`

  The number of time-steps to do in the time propagation. The default
  value is 100.

  Shell example:  `inq real-time num-steps 10000`
  Python example: `pinq.real_time.num-steps(10000)`


- Shell:  `real-time propagation-time <value> <units>`
  Python: `real_time.propagation_time(value, units)`

  Sets the number of step so that the total propagation time is
  (slightly larger than) `value`. You need to pass the units as a
  second argument, you can use "atu" (or "atomictimeunits"), "as" or
  "fs" among others.

  Note that this variable directly calculates the number of steps
  based on the currently defined time-step. If the time-step is later
  changed the number of steps will remain unchanged and the
  propagation time will change.

  Shell example:  `inq real-time propagation-time 10.0 fs`
  Python example: `pinq.real_time.propagation_time(10.0, "fs")`


- Shell:  `real-time ions <value>`
  Python: `real_time.ions.static()`
          `real_time.ions.impulsive()`
          `real_time.ions.ehrenfest()`

  This value decides how the ions will move during the
  time-propagation. The options are: `static`, `impulsive` and
  `ehrenfest`.

  The default is `static` where the ions don't move during the propagation.

  In `impulsive` the ions move with a constant velocity given by the
  initial conditions. This implies that the energy is not conserved.

  The last option is `ehrenfest` dynamics, where the ions follow the
  instantaneous classical forces generated by the electrons.

  Note that when ions move, inq has to recalculate the atomic
  potential at each step, so the propagation will be more costly.

  Shell example:  `inq real-time ions ehrenfest`
  Python example: `pinq.real_time.ions.ehrenfest()`


- Shell:  `real-time observables <value>`
  Python: `real_time.observables.dipole()`
          `real_time.observables.current()`

  This value decides what observables will be calculated the
  time-propagation. Right now the options are are: `dipole` and
  `current` The total energy is also always calculated.

  Several calls to this function will add more observables.
 
  Note that the calculated values will be stored internally by
  INQ. They can be queried after the simulation is complete with the
  `results real-time` command.

  Shell example:  `inq real-time observables current`
  Python example: `pinq.real_time.observables.current()`


- Shell:  `real-time observables clear`
  Python: `real_time.observables.clear()`

  This option removes all the observables that have been previously
  requested.

  Shell example:  `inq real-time observables clear`
  Python example: `pinq.real_time.observables.clear()`


)"""";
	}

	static void status() {
		auto opts = options::real_time::load(".inq/default_real_time_options");
		if(input::environment::global().comm().root()) std::cout << opts;
	}
	
	void operator()() const {
		status();
	}

	static void time_step(quantity<magnitude::time> dt) {
		using namespace magnitude;

		auto opts = options::real_time::load(".inq/default_real_time_options").dt(dt);
		opts.save(input::environment::global().comm(), ".inq/default_real_time_options");
	}
	
	static void num_steps(long nsteps) {
		auto opts = options::real_time::load(".inq/default_real_time_options").num_steps(nsteps);
		opts.save(input::environment::global().comm(), ".inq/default_real_time_options");
	}

	static void propagation_time(quantity<magnitude::time> pt) {
		using namespace magnitude;

		auto opts = options::real_time::load(".inq/default_real_time_options").propagation_time(pt);
		opts.save(input::environment::global().comm(), ".inq/default_real_time_options");
	}
	
	static void ions_static() {
		auto opts = options::real_time::load(".inq/default_real_time_options").static_ions();
		opts.save(input::environment::global().comm(), ".inq/default_real_time_options");
	}

	static void ions_impulsive() {
		auto opts = options::real_time::load(".inq/default_real_time_options").impulsive();
		opts.save(input::environment::global().comm(), ".inq/default_real_time_options");
	}
	
	static void ions_ehrenfest() {
		auto opts = options::real_time::load(".inq/default_real_time_options").ehrenfest();
		opts.save(input::environment::global().comm(), ".inq/default_real_time_options");
	}

	static void observables_dipole() {
		auto opts = options::real_time::load(".inq/default_real_time_options").observables_dipole();
		opts.save(input::environment::global().comm(), ".inq/default_real_time_options");
	}

	static void observables_current() {
		auto opts = options::real_time::load(".inq/default_real_time_options").observables_current();
		opts.save(input::environment::global().comm(), ".inq/default_real_time_options");
	}

	static void observables_clear() {
		auto opts = options::real_time::load(".inq/default_real_time_options").observables_clear();
		opts.save(input::environment::global().comm(), ".inq/default_real_time_options");
	}
	
	template <typename ArgsType>
	void command(ArgsType args, runtime_options const & run_opts) const {
		using utils::str_to;
		
		if(args.size() == 0) {
			operator()();
			actions::normal_exit();
		}

		if(args.size() == 3 and (args[0] == "time-step")){
			time_step(magnitude::time::parse(str_to<double>(args[1]), args[2]));
			if(not run_opts.quiet) operator()();
			actions::normal_exit();
		}

		if(args.size() == 3 and (args[0] == "propagation-time")){
			propagation_time(magnitude::time::parse(str_to<double>(args[1]), args[2]));
			if(not run_opts.quiet) operator()();
			actions::normal_exit();
		}
				
		if(args.size() == 2 and (args[0] == "num-steps")){
			num_steps(str_to<long>(args[1]));
			if(not run_opts.quiet) operator()();
			actions::normal_exit();
		}

		if(args[0] == "ions"){
			args.erase(args.begin());

			if(args.size() == 1 and args[0] == "static"){
				ions_static();
				if(not run_opts.quiet) operator()();
				actions::normal_exit();
			}
			
			if(args.size() == 1 and args[0] == "impulsive"){
				ions_impulsive();
				if(not run_opts.quiet) operator()();
				actions::normal_exit();
			}
			
			if(args.size() == 1 and args[0] == "ehrenfest"){
				ions_ehrenfest();
				if(not run_opts.quiet) operator()();
				actions::normal_exit();
			}
			
			actions::error(input::environment::global().comm(), "Invalid arguments for 'real-time ions' command");
		}

		if(args[0] == "observables"){
			args.erase(args.begin());
			
			if(args.size() == 1 and args[0] == "dipole"){
				observables_dipole();
				if(not run_opts.quiet) operator()();
				actions::normal_exit();
			}
			
			if(args.size() == 1 and args[0] == "current"){
				observables_current();
				if(not run_opts.quiet) operator()();
				actions::normal_exit();
			}
			
			if(args.size() == 1 and args[0] == "clear"){
				observables_clear();
				if(not run_opts.quiet) operator()();
				actions::normal_exit();
			}
			
			actions::error(input::environment::global().comm(), "Invalid arguments for 'real-time observables' command");
		}
						
		actions::error(input::environment::global().comm(), "Invalid syntax in 'real-time' command");
	}
	
#ifdef INQ_PYTHON_INTERFACE
	template <class PythonModule>
	void python_interface(PythonModule & module) const {
		namespace py = pybind11;
		using namespace pybind11::literals;

		auto sub = module.def_submodule("real_time", help());
		
		sub.def("status", &status);
		
		sub.def("time_step", [](double dt, std::string const & units){
			time_step(magnitude::time::parse(dt, units));
		}, "dt"_a, "units"_a);

		sub.def("propagation_time", [](double time, std::string const & units){
			propagation_time(magnitude::time::parse(time, units));
		}, "time"_a, "units"_a);
		
		sub.def("num_steps", &num_steps);

		auto sub_ions = sub.def_submodule("ions");
		sub_ions.def("static",    &ions_static);
		sub_ions.def("impulsive", &ions_impulsive);	
		sub_ions.def("ehrenfest", &ions_ehrenfest);

		auto sub_observables = sub.def_submodule("observables");
		sub_observables.def("dipole",    &observables_dipole);
		sub_observables.def("current", &observables_current);	
		sub_observables.def("clear", &observables_clear);

	}
#endif
	
} const real_time;

}
}
#endif

#ifdef INQ_INTERFACE_REAL_TIME_UNIT_TEST
#undef INQ_INTERFACE_REAL_TIME_UNIT_TEST

#include <catch2/catch_all.hpp>

TEST_CASE(INQ_TEST_FILE, INQ_TEST_TAG) {

	using namespace inq;
	using namespace Catch::literals;

}
#endif
